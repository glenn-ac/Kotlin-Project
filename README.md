Question Time - Interactive Study Application

An interactive terminal-based study application built in Kotlin that helps users practice questions through an adaptive learning system. The application supports multiple question banks, intelligent answer classification, and provides a comprehensive study experience.

Features

Multiple Question Bank Types: File-based questions, auto-generated mathematical problems, and filtered question sets
Intelligent Answer Classification: Two classification systems - naive (Y/N detection) and advanced (k-NN with Levenshtein distance)
Adaptive Learning: Questions answered incorrectly are cycled back to the end for additional practice
Interactive Menu System: User-friendly terminal interface for selecting question banks and classifiers
Comprehensive Testing: Built-in test suite covering all core functionality

How to Run

Prerequisites
- Kotlin compiler installed
- Java Runtime Environment (JRE)

Execution
kotlinc -script question-time-part-ii.main.kts -cp khoury.jar

The application will start with an interactive menu where you can:
1. Choose a question bank (file-based, auto-generated, or filtered)
2. Select a classifier (naive or advanced)
3. Begin your study session

Project Structure & Logic

Core Components

1. Question Management (TaggedQuestion)
Purpose: Represents individual questions with metadata
Structure: Question text, answer, and tags for categorization
Key Methods: hasTag(), format()

2. Question Banks (IQuestionBank Interface)
Three implementations provide different question sources:

ListBasedQuestionBank: Manages questions from files or filtered lists
AutoGeneratedQuestionBank: Creates mathematical questions (e.g., cubed numbers)
FilteredQuestionBank: Filters existing question banks by tags

State Management: Uses QuestionBankState enum (QUESTIONING, ANSWERING, COMPLETED) to track session progress.

3. Answer Classification System
Two classification approaches:

Naive Classifier: Simple Y/N detection based on string starting with 'Y' or 'y'
Advanced Classifier: k-Nearest Neighbors algorithm using Levenshtein distance for fuzzy matching

4. Interactive Study Session (reactConsole Integration)
State Machine: Manages study flow through stages (question → answer → feedback)
Adaptive Logic: Correct answers remove questions; incorrect answers cycle them to the end
Progress Tracking: Monitors attempts and completion status

Key Algorithms

Levenshtein Distance
Purpose: Measures string similarity for advanced classification
Implementation: Immutable functional approach using fold operations
Usage: Enables fuzzy matching for user input classification

k-Nearest Neighbors (k-NN)
Purpose: Classifies user input based on similarity to training data
Process: Finds k closest examples, votes on classification
Training Data: Predefined positive/negative examples for sentiment analysis

Data Flow

1. Initialization: Load question bank and classifier based on user selection
2. Study Loop: 
   Display question → User presses Enter → Show answer
   User indicates correctness → Update question bank state
   Repeat until all questions answered correctly
3. Completion: Display session statistics (questions attempted, total attempts)

File Structure
question-time-part-ii.main.kts  # Main application file
questions.txt                   # Sample question data
khoury.jar                      # Required library for testing framework

Testing

The application includes comprehensive test coverage:
- Question bank functionality
- Classification algorithms  
- String similarity calculations
- State management logic

Tests run automatically when the application starts, providing immediate feedback on system integrity.

Technical Highlights

Functional Programming: Immutable data structures and pure functions
Type Safety: Strong typing throughout with Kotlin's type system
Modular Design: Clean separation of concerns with interfaces and implementations
Error Handling: Graceful handling of edge cases and invalid inputs


